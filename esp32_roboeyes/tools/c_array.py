#!/usr/bin/env python3
"""
RoboEyes C Array Exporter v1.0
================================
Converte frames PNG gerados pelo engine.py em arrays C
para uso direto no Arduino/ESP32.

Features:
- Exporta frames como PROGMEM byte arrays
- Alerta de mem√≥ria configur√°vel via YAML (memory_limit)
- Gera header (.h) pronto para #include
- Suporte a m√∫ltiplas anima√ß√µes

Uso:
    python c_array.py output/ --config animations/example.yaml
    python c_array.py output/ --config animations/example.yaml --output anim_data.h
"""

import argparse
import glob
import os
import sys

try:
    import yaml
except ImportError:
    print("‚ùå Instale PyYAML: pip install pyyaml")
    sys.exit(1)

try:
    from PIL import Image
except ImportError:
    print("‚ùå Instale Pillow: pip install pillow")
    sys.exit(1)


# ============================================================
# FRAME TO BYTES
# ============================================================

def frame_to_bytes(img, canvas_w, canvas_h):
    """
    Converte uma imagem 1-bit para array de bytes.
    Cada byte = 8 pixels horizontais (MSB first).
    Formato compat√≠vel com Adafruit GFX drawBitmap().
    """
    img = img.convert("1")
    pixels = img.load()
    byte_width = (canvas_w + 7) // 8
    data = []

    for y in range(canvas_h):
        for bx in range(byte_width):
            byte_val = 0
            for bit in range(8):
                x = bx * 8 + bit
                if x < canvas_w:
                    # Pillow 1-bit: 0=black, 255=white
                    if pixels[x, y] > 0:
                        byte_val |= (0x80 >> bit)
            data.append(byte_val)

    return data


# ============================================================
# C CODE GENERATOR
# ============================================================

def generate_c_header(animations_data, canvas_w, canvas_h, config):
    """Gera o conte√∫do do arquivo .h com todos os arrays."""

    memory_limit = config.get("memory_limit", 32) * 1024
    total_bytes = 0
    lines = []

    lines.append("// ============================================================")
    lines.append(f"// RoboEyes Animation Data ‚Äî Auto-generated by c_array.py")
    lines.append(f"// Canvas: {canvas_w}x{canvas_h}")
    lines.append(f"// Memory limit: {config.get('memory_limit', 32)} KB")
    lines.append("// ============================================================")
    lines.append(f"// ‚ö†Ô∏è  N√ÉO EDITE MANUALMENTE ‚Äî Gerado automaticamente")
    lines.append("// ============================================================")
    lines.append("")
    lines.append("#pragma once")
    lines.append("")
    lines.append("#include <Arduino.h>")
    lines.append("#include <avr/pgmspace.h>  // Para PROGMEM (Arduino AVR)")
    lines.append("")
    lines.append(f"#define ANIM_CANVAS_W {canvas_w}")
    lines.append(f"#define ANIM_CANVAS_H {canvas_h}")
    lines.append(f"#define ANIM_BYTE_WIDTH {(canvas_w + 7) // 8}")
    lines.append(f"#define ANIM_FRAME_BYTES {((canvas_w + 7) // 8) * canvas_h}")
    lines.append("")

    # Gerar arrays por anima√ß√£o
    anim_names = []
    anim_frame_counts = []

    for anim_name, frames_bytes in animations_data.items():
        safe_name = anim_name.replace("-", "_").replace(" ", "_").lower()
        n_frames = len(frames_bytes)
        anim_names.append(safe_name)
        anim_frame_counts.append(n_frames)

        lines.append(f"// --- {anim_name} ({n_frames} frames) ---")

        for i, frame_data in enumerate(frames_bytes):
            total_bytes += len(frame_data)
            hex_str = ", ".join(f"0x{b:02X}" for b in frame_data)

            lines.append(f"const uint8_t PROGMEM {safe_name}_frame_{i}[] = {{")

            # Quebrar em linhas de 16 bytes
            chunk_size = 16
            for j in range(0, len(frame_data), chunk_size):
                chunk = frame_data[j:j + chunk_size]
                hex_line = ", ".join(f"0x{b:02X}" for b in chunk)
                comma = "," if j + chunk_size < len(frame_data) else ""
                lines.append(f"  {hex_line}{comma}")

            lines.append("};")
            lines.append("")

        # Array de ponteiros para os frames
        lines.append(f"const uint8_t* const PROGMEM {safe_name}_frames[] = {{")
        refs = [f"  {safe_name}_frame_{i}" for i in range(n_frames)]
        lines.append(",\n".join(refs))
        lines.append("};")
        lines.append(f"#define {safe_name.upper()}_FRAME_COUNT {n_frames}")
        lines.append("")

    # Struct de info
    lines.append("// --- Animation Registry ---")
    lines.append("typedef struct {")
    lines.append("  const char* name;")
    lines.append("  const uint8_t* const* frames;")
    lines.append("  uint16_t frameCount;")
    lines.append("} AnimationInfo;")
    lines.append("")
    lines.append(f"#define ANIM_TOTAL_COUNT {len(anim_names)}")
    lines.append("")
    lines.append("const AnimationInfo ANIM_REGISTRY[] = {")
    for name, count in zip(anim_names, anim_frame_counts):
        lines.append(f'  {{"{name}", {name}_frames, {count}}},')
    lines.append("};")
    lines.append("")

    # Resumo
    lines.append(f"// Total bytes: {total_bytes:,} ({total_bytes / 1024:.1f} KB)")
    if total_bytes > memory_limit:
        lines.append(f"// ‚ö†Ô∏è  ATEN√á√ÉO: Excede limite de {memory_limit // 1024} KB!")
    else:
        lines.append(f"// ‚úÖ Dentro do limite de {memory_limit // 1024} KB "
                     f"({total_bytes * 100 // memory_limit}% usado)")
    lines.append("")

    return "\n".join(lines), total_bytes


# ============================================================
# FRAME LOADER
# ============================================================

def load_frames_from_dir(frames_dir, canvas_w, canvas_h):
    """Carrega frames PNG de subdiret√≥rios organizados pelo engine.py."""
    animations = {}

    if not os.path.isdir(frames_dir):
        print(f"‚ùå Diret√≥rio n√£o encontrado: {frames_dir}")
        return animations

    # Cada subdiret√≥rio = uma anima√ß√£o
    subdirs = sorted([
        d for d in os.listdir(frames_dir)
        if os.path.isdir(os.path.join(frames_dir, d))
    ])

    if not subdirs:
        # Talvez os PNGs estejam direto na raiz
        png_files = sorted(glob.glob(os.path.join(frames_dir, "*.png")))
        if png_files:
            subdirs = ["."]

    for subdir in subdirs:
        if subdir == ".":
            anim_dir = frames_dir
            anim_name = os.path.basename(frames_dir)
        else:
            anim_dir = os.path.join(frames_dir, subdir)
            anim_name = subdir

        png_files = sorted(glob.glob(os.path.join(anim_dir, "*.png")))
        if not png_files:
            continue

        frames_bytes = []
        for png_path in png_files:
            img = Image.open(png_path).convert("1")

            # Redimensionar se necess√°rio
            if img.size != (canvas_w, canvas_h):
                img = img.resize((canvas_w, canvas_h), Image.NEAREST)

            frame_data = frame_to_bytes(img, canvas_w, canvas_h)
            frames_bytes.append(frame_data)

        animations[anim_name] = frames_bytes
        print(f"  üì¶ {anim_name}: {len(frames_bytes)} frames carregados")

    return animations


# ============================================================
# MAIN
# ============================================================

def main():
    parser = argparse.ArgumentParser(
        description="ü§ñ RoboEyes C Array Exporter ‚Äî Converte frames para .h"
    )
    parser.add_argument("frames_dir", help="Diret√≥rio com frames PNG (sa√≠da do engine.py)")
    parser.add_argument("--config", "-c", required=True,
                        help="Arquivo YAML com configura√ß√£o (para memory_limit)")
    parser.add_argument("--output", "-o", default="anim_data.h",
                        help="Arquivo de sa√≠da .h (padr√£o: anim_data.h)")
    parser.add_argument("--verbose", "-v", action="store_true",
                        help="Modo verboso")
    args = parser.parse_args()

    # Load config
    if not os.path.exists(args.config):
        print(f"‚ùå Config n√£o encontrado: {args.config}")
        sys.exit(1)

    with open(args.config, "r") as f:
        config = yaml.safe_load(f)

    canvas_w = config.get("canvas", {}).get("width", 128)
    canvas_h = config.get("canvas", {}).get("height", 64)
    memory_limit_kb = config.get("memory_limit", 32)

    print(f"\n{'='*50}")
    print(f"ü§ñ RoboEyes C Array Exporter v1.0")
    print(f"{'='*50}")
    print(f"üìê Canvas: {canvas_w}x{canvas_h}")
    print(f"üíæ Limite mem√≥ria: {memory_limit_kb} KB")
    print(f"üìÇ Input : {args.frames_dir}")
    print(f"üìÑ Output: {args.output}")
    print(f"{'='*50}\n")

    # Load frames
    print("üì¶ Carregando frames...")
    animations = load_frames_from_dir(args.frames_dir, canvas_w, canvas_h)

    if not animations:
        print("‚ùå Nenhuma anima√ß√£o encontrada!")
        sys.exit(1)

    total_frames = sum(len(v) for v in animations.values())
    print(f"\n   Total: {total_frames} frames em {len(animations)} anima√ß√£o(√µes)")

    # Generate C header
    print("\n‚öôÔ∏è  Gerando C header...")
    c_content, total_bytes = generate_c_header(animations, canvas_w, canvas_h, config)

    # Write output
    output_path = args.output
    os.makedirs(os.path.dirname(output_path) if os.path.dirname(output_path) else ".", exist_ok=True)
    with open(output_path, "w") as f:
        f.write(c_content)

    print(f"\n‚úÖ Header gerado: {output_path}")

    # Memory report
    memory_limit = memory_limit_kb * 1024
    print(f"\n{'='*50}")
    print(f"üìä Relat√≥rio de Mem√≥ria")
    print(f"{'='*50}")
    print(f"   Frames totais:     {total_frames}")
    print(f"   Bytes por frame:   {((canvas_w + 7) // 8) * canvas_h}")
    print(f"   Total de dados:    {total_bytes:,} bytes ({total_bytes/1024:.1f} KB)")
    print(f"   Limite configurado: {memory_limit_kb} KB ({memory_limit:,} bytes)")

    used_pct = (total_bytes / memory_limit) * 100
    bar_len = 30
    filled = int(bar_len * min(used_pct, 100) / 100)
    bar = "‚ñà" * filled + "‚ñë" * (bar_len - filled)

    if total_bytes > memory_limit:
        print(f"\n   [{bar}] {used_pct:.0f}%")
        print(f"   \033[93m‚ö†Ô∏è  WARNING: Anima√ß√£o excede o limite de {memory_limit_kb}KB!\033[0m")
        print(f"   \033[93m    {total_bytes/1024:.1f}KB > {memory_limit_kb}KB\033[0m")
        print(f"\n   üí° Sugest√µes:")
        print(f"      - Reduza o FPS (ex: fps: 8)")
        print(f"      - Diminua a dura√ß√£o das anima√ß√µes")
        print(f"      - Use canvas menor (ex: 64x32)")
        print(f"      - Aumente memory_limit se usando ESP32")

        # Specific platform suggestions
        if memory_limit_kb <= 32:
            print(f"\n   üìå Detectado limite Arduino Uno (32KB).")
            print(f"      Se for ESP32, defina memory_limit: 512 no YAML.")
    else:
        print(f"\n   [{bar}] {used_pct:.0f}%")
        print(f"   \033[92m‚úÖ Dentro do limite! ({total_bytes/1024:.1f}KB de {memory_limit_kb}KB)\033[0m")

    print(f"\n{'='*50}")
    print(f"‚ú® Para usar no Arduino/ESP32:")
    print(f'   #include "{os.path.basename(output_path)}"')
    print(f"   // drawBitmap(0, 0, {list(animations.keys())[0]}_frame_0,")
    print(f"   //   ANIM_CANVAS_W, ANIM_CANVAS_H, SSD1306_WHITE);")
    print(f"{'='*50}\n")


if __name__ == "__main__":
    main()
